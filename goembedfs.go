// Copyright (c) 2018, Janoš Guljaš <janos@resenje.org>
// All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found s the LICENSE file.

package goembedfs

import (
	"bytes"
	"compress/gzip"
	"crypto/sha1"
	"fmt"
	"html/template"
	"io"
	"sort"
	"strings"
	"time"
)

// Generator writes generated Go source file.
type Generator struct {
	w      io.Writer
	names  map[string]struct{}
	hashes map[[20]byte]struct{}

	headerWritten       bool
	packageName         string
	tags                []string
	gzipEnabled         bool
	minGzipSpaceSavings float64
}

// Option sets optional parameters for Generator.
// It is used as variadic argument in the New function.
type Option func(*Generator)

// WithTags adds build tags to the generated package.
// This option can be repeated as argument in the New function.
func WithTags(tags ...string) Option {
	return func(g *Generator) {
		g.tags = append(g.tags, tags...)
	}
}

// WithGzip sets if gzip compression is enabled.
// Compressing data with gzip reduces binary file size,
// but delays calling the main function as decompressions
// is performed in the init function.
func WithGzip(enabled bool) Option {
	return func(g *Generator) {
		g.gzipEnabled = enabled
	}
}

// WithMinGzipSpaceSavings sets the minimal space savings
// for gzipped data in order to be generated as gzip.
// The range must be [0..100] (percentage) where
// 0 represents no space saving.
func WithMinGzipSpaceSavings(s float64) Option {
	return func(g *Generator) {
		if s > 100 {
			s = 100
		}
		g.minGzipSpaceSavings = s / 100
	}
}

// New returns a new instance of Generator that writes to provided writer
// a Go generated package with provied package name and optional parameters.
func New(w io.Writer, packageName string, opts ...Option) (g *Generator) {
	g = &Generator{
		w:           w,
		names:       make(map[string]struct{}),
		hashes:      make(map[[20]byte]struct{}),
		packageName: packageName,
	}
	for _, opt := range opts {
		opt(g)
	}
	return g
}

// AddFile adds a single file with name as full path, data and modification time.
func (g *Generator) AddFile(name string, data []byte, modTime time.Time) (err error) {
	if err := g.writeHeader(); err != nil {
		return err
	}

	if _, ok := g.names[name]; ok {
		return fmt.Errorf("duplicate file: %q", name)
	}
	g.names[name] = struct{}{}

	hash := sha1.Sum(data)
	size := len(data)
	if _, ok := g.hashes[hash]; !ok {
		var gzipData []byte
		if g.gzipEnabled {
			var buf bytes.Buffer
			w := gzip.NewWriter(&buf)
			if _, err := io.Copy(w, bytes.NewReader(data)); err != nil {
				return fmt.Errorf("gzip: %v", err)
			}
			if err := w.Close(); err != nil {
				return fmt.Errorf("close gzip: %v", err)
			}
			gzipData = buf.Bytes()
		}
		if g.gzipEnabled && float64(len(gzipData))/float64(size) <= (1-g.minGzipSpaceSavings) {
			_, err = fmt.Fprintf(g.w, "	data%x := gunzip([]byte(\"%v\"))\n", hash, hex(gzipData))
		} else {
			_, err = fmt.Fprintf(g.w, "	data%x := []byte(\"%v\")\n", hash, hex(data))
		}
		if err != nil {
			return err
		}
		g.hashes[hash] = struct{}{}
	}

	name = strings.Replace(name, "\\", "/", -1)
	modTimeUnix := modTime.UnixNano()
	sec := int64(time.Second)

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "	files[%q] = &File{\n", name)
	fmt.Fprintf(&buf, "		name:    %q,\n", name)
	fmt.Fprintf(&buf, "		size:    %d,\n", size)
	fmt.Fprintf(&buf, "		modTime: time.Unix(%d, %d),\n", modTimeUnix/sec, modTimeUnix%sec)
	fmt.Fprintf(&buf, "		data:    data%x,\n", hash)
	fmt.Fprintf(&buf, "		Reader:  bytes.NewReader(data%x),\n", hash)
	fmt.Fprintf(&buf, "	}\n\n")
	_, err = buf.WriteTo(g.w)
	return err
}

// WriteFooter writes the rest of generated file.
func (g *Generator) WriteFooter() error {
	if err := g.writeHeader(); err != nil {
		return err
	}
	return g.writeFooter()
}

// writeHeader writes the start of the file and ensures that it is
// called only once for a singel Generator instance.
func (g *Generator) writeHeader() (err error) {
	if g.headerWritten {
		return nil
	}

	// comment
	_, err = fmt.Fprintf(g.w, `// Code generated by resenje.org/goembedfs.
// DO NOT EDIT.

`)
	if err != nil {
		return err
	}

	// tags
	var hasTags bool
	for _, tag := range g.tags {
		tag = strings.TrimSpace(tag)
		if tag == "" {
			continue
		}
		_, err = fmt.Fprintf(g.w, "// +build %s\n", tag)
		if err != nil {
			return err
		}
		hasTags = true
	}
	if hasTags {
		_, err = fmt.Fprintln(g.w, "")
		if err != nil {
			return err
		}
	}

	// package
	// imports
	// types
	// functions
	err = template.Must(template.New("").Parse(`package {{ .PackageName }}

import (
	"bytes"
	{{- if .Gzip }}
	"compress/gzip"
	{{- end }}
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

var files = make(map[string]*File)

// File implements http.File interface with additional Data method.
type File struct {
	name    string
	size    int64
	modTime time.Time
	data    []byte
	*bytes.Reader
}

// Name returns the name of file.
func (f *File) Name() (name string) { return f.name }

// Data returns complete data of file.
func (f *File) Data() (data []byte) { return f.data }

// Close does not close anything. It seeks the Reader to
// start of the file to ensure that can be read again.
func (f *File) Close() (err error) {
	_, err = f.Reader.Seek(0, io.SeekStart)
	return err
}

// Stat returns os.FileInfo.
func (f *File) Stat() (fi os.FileInfo, err error) { return f, nil }

// Size returns the size of file data in bytes.
func (f *File) Size() int64 { return f.size }

// Mode always returns all read permissions.
func (f *File) Mode() (mode os.FileMode) { return 0444 }

// ModTime returns file modification time.
func (f *File) ModTime() (t time.Time) { return f.modTime }

// IsDir always returns false.
func (f *File) IsDir() (yes bool) { return false }

// Sys always returns nil.
func (f *File) Sys() (i interface{}) { return nil }

// Readdir always returns os.PathError with os.ErrPermission.
func (f *File) Readdir(_ int) (ff []os.FileInfo, err error) {
	return nil, &os.PathError{Path: f.name, Err: os.ErrPermission}
}

// ReadFile returns complete data for a particular file.
// This function is analogous to ioutil.ReadFile.
func ReadFile(name string) (data []byte, err error) {
	f, err := Open(name)
	if err != nil {
		return nil, err
	}
	return f.data, nil
}

// Open returns File for a particular name. 
func Open(name string) (f *File, err error) {
	name = strings.Replace(name, "\\", "/", -1)
	if len(name) > 0 && name[0] == '/' {
		name = name[1:]
	}
	f = files[name]
	if f == nil {
		return nil, &os.PathError{Path: name, Err: os.ErrNotExist}
	}
	return f, nil
}

// Filenames returns the list of all available file names.
func Filenames() []string {
	return filenames
}

// FileSystem implements http.FileSystem interface.
func FileSystem() (fs http.FileSystem) { return &fileSystem{} }

type fileSystem struct{}

func (fs *fileSystem) Open(name string) (f http.File, err error) {
	return Open(name)
}

{{- if .Gzip }}

func gunzip(data []byte) (d []byte) {
	r, err := gzip.NewReader(bytes.NewReader(data))
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	if _, err := io.Copy(&buf, r); err != nil {
		panic(err)
	}
	if err := r.Close(); err != nil {
		panic(err)
	}
	return buf.Bytes()
}
{{- end }}

func init() {
`)).Execute(g.w, map[string]interface{}{
		"PackageName": g.packageName,
		"Gzip":        g.gzipEnabled,
	})
	if err != nil {
		return err
	}
	g.headerWritten = true
	return nil
}

// writeFooter writes all asset names to a variable named assetNames.
func (g *Generator) writeFooter() (err error) {
	_, err = fmt.Fprint(g.w, "}\n\n")
	if err != nil {
		return err
	}

	names := make([]string, 0, len(g.names))
	for name := range g.names {
		names = append(names, name)
	}
	sort.Strings(names)

	_, err = fmt.Fprintln(g.w, `var filenames = []string{`)
	if err != nil {
		return err
	}
	for _, name := range names {
		_, err = fmt.Fprintf(g.w, "	%q,\n", name)
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprint(g.w, "}\n\n")
	return err
}

// hex returns a hexadecimal encoding of bytes.
func hex(data []byte) string {
	buf := make([]byte, 4*len(data))
	const digits = "0123456789abcdef"
	for i, b := range data {
		buf[i*4] = '\\'
		buf[(i*4)+1] = 'x'
		buf[(i*4)+2] = digits[b>>4]
		buf[(i*4)+3] = digits[b&0x0F]
	}
	return string(buf)
}
