// Copyright (c) 2018, Janoš Guljaš <janos@resenje.org>
// All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found s the LICENSE file.

package goembedfs

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"io"
	"sort"
	"strings"
	"time"
)

// Generator writes generated Go source file.
type Generator struct {
	w      io.Writer
	names  map[string]struct{}
	hashes map[[20]byte]struct{}

	headerWritten bool
	packageName   string
	tags          []string
}

// New returns a new instance of Generator that writes to provided writer
// a Go generated package with provied package name and build tags.
func New(w io.Writer, packageName string, tags []string) *Generator {
	return &Generator{
		w:           w,
		names:       make(map[string]struct{}),
		hashes:      make(map[[20]byte]struct{}),
		packageName: packageName,
		tags:        tags,
	}
}

// AddFile adds a single file with name as full path, data and modification time.
func (g *Generator) AddFile(name string, data []byte, modTime time.Time) (err error) {
	if err := g.writeHeader(); err != nil {
		return err
	}

	if _, ok := g.names[name]; ok {
		return fmt.Errorf("duplicate file: %q", name)
	}
	g.names[name] = struct{}{}

	hash := sha1.Sum(data)
	if _, ok := g.hashes[hash]; !ok {
		_, err = fmt.Fprintf(g.w, "	data%x := []byte(\"%v\")\n", hash, hex(data))
		if err != nil {
			return err
		}
		g.hashes[hash] = struct{}{}
	}

	name = strings.Replace(name, "\\", "/", -1)
	modTimeUnix := modTime.UnixNano()
	sec := int64(time.Second)

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "	files[%q] = &File{\n", name)
	fmt.Fprintf(&buf, "		name:    %q,\n", name)
	fmt.Fprintf(&buf, "		size:    %d,\n", len(data))
	fmt.Fprintf(&buf, "		modTime: time.Unix(%d, %d),\n", modTimeUnix/sec, modTimeUnix%sec)
	fmt.Fprintf(&buf, "		data:    data%x,\n", hash)
	fmt.Fprintf(&buf, "		Reader:  bytes.NewReader(data%x),\n", hash)
	fmt.Fprintf(&buf, "	}\n\n")
	_, err = buf.WriteTo(g.w)
	return err
}

// WriteFooter writes the rest of generated file.
func (g *Generator) WriteFooter() error {
	if err := g.writeHeader(); err != nil {
		return err
	}
	return g.writeFooter()
}

// writeHeader writes the start of the file and ensures that it is
// called only once for a singel Generator instance.
func (g *Generator) writeHeader() (err error) {
	if g.headerWritten {
		return nil
	}

	// comment
	_, err = fmt.Fprintf(g.w, `// Code generated by resenje.org/goembedfs.
// DO NOT EDIT.

`)
	if err != nil {
		return err
	}

	// tags
	var hasTags bool
	for _, tag := range g.tags {
		tag = strings.TrimSpace(tag)
		if tag == "" {
			continue
		}
		_, err = fmt.Fprintf(g.w, "// +build %s\n", tag)
		if err != nil {
			return err
		}
		hasTags = true
	}
	if hasTags {
		_, err = fmt.Fprintln(g.w, "")
		if err != nil {
			return err
		}
	}

	// package
	// imports
	// types
	// functions
	_, err = fmt.Fprintf(g.w, `package %s

import (
	"bytes"
	"net/http"
	"os"
	"strings"
	"time"
)

var files = make(map[string]*File)

// File implements http.File interface with additional Data method.
type File struct {
	name    string
	size    int64
	modTime time.Time
	data    []byte
	*bytes.Reader
}

// Name returns the name of file.
func (f *File) Name() (name string) { return f.name }

// Data returns complete data of file.
func (f *File) Data() (data []byte) { return f.data }

// Close does not do anything. 
func (f *File) Close() (err error) { return nil }

// Stat returns os.FileInfo.
func (f *File) Stat() (fi os.FileInfo, err error) { return f, nil }

// Size returns the size of file data in bytes.
func (f *File) Size() int64 { return f.size }

// Mode always returns all read permissions.
func (f *File) Mode() (mode os.FileMode) { return 0444 }

// ModTime returns file modification time.
func (f *File) ModTime() (t time.Time) { return f.modTime }

// IsDir always returns false.
func (f *File) IsDir() (yes bool) { return false }

// Sys always returns nil.
func (f *File) Sys() (i interface{}) { return nil }

// Readdir always returns os.PathError with os.ErrPermission.
func (f *File) Readdir(_ int) (ff []os.FileInfo, err error) {
	return nil, &os.PathError{Path: f.name, Err: os.ErrPermission}
}

// ReadFile returns complete data for a particular file.
// This function is analogous to ioutil.ReadFile.
func ReadFile(name string) (data []byte, err error) {
	f, err := Open(name)
	if err != nil {
		return nil, err
	}
	return f.data, nil
}

// Open returns File for a particular name. 
func Open(name string) (f *File, err error) {
	name = strings.Replace(name, "\\", "/", -1)
	if len(name) > 0 && name[0] == '/' {
		name = name[1:]
	}
	f = files[name]
	if f == nil {
		return nil, &os.PathError{Path: name, Err: os.ErrNotExist}
	}
	return f, nil
}

// Filenames returns the list of all available file names.
func Filenames() []string {
	return filenames
}

// FileSystem implements http.FileSystem interface.
func FileSystem() (fs http.FileSystem) { return &fileSystem{} }

type fileSystem struct{}

func (fs *fileSystem) Open(name string) (f http.File, err error) {
	return Open(name)
}

func init() {
`, g.packageName)
	if err != nil {
		return err
	}

	g.headerWritten = true
	return nil
}

// writeFooter writes all asset names to a variable named assetNames.
func (g *Generator) writeFooter() (err error) {
	_, err = fmt.Fprint(g.w, "}\n\n")
	if err != nil {
		return err
	}

	names := make([]string, 0, len(g.names))
	for name := range g.names {
		names = append(names, name)
	}
	sort.Strings(names)

	_, err = fmt.Fprintln(g.w, `var filenames = []string{`)
	if err != nil {
		return err
	}
	for _, name := range names {
		_, err = fmt.Fprintf(g.w, "	%q,\n", name)
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprint(g.w, "}\n\n")
	return err
}

// hex returns a hexadecimal encoding of bytes.
func hex(data []byte) string {
	buf := make([]byte, 4*len(data))
	const digits = "0123456789abcdef"
	for i, b := range data {
		buf[i*4] = '\\'
		buf[(i*4)+1] = 'x'
		buf[(i*4)+2] = digits[b>>4]
		buf[(i*4)+3] = digits[b&0x0F]
	}
	return string(buf)
}
